---
layout: post
title: Java笔记 线程
date: 2020-7-5
Author: Ain
tags: [Java,基础]
comments: true
---

1.（这部分属于了解）关于线程的调度

​	1.1 常见的线程调度模型

​		抢占式调度模型：哪个线程的优先级比较高。抢到的CPU时间片的概率就高一些

​		均分式调度模型：平均分配CPU时间片，每个线程占有的CPU时间片时间长度一样。

​	1.2 Java中提供了哪些方法是和线程调度有关的？

​		实例方法：

```java
	 void setPriority(int newPriority)  设置线程的优先级
	 int getPriority()  获取线程的优先级
```

​		最低优先级是1、默认优先级是5，最高优先级是10

​		优先级高的获取CPU时间片可能会多一些。（但不完全是，大概率是多的）

​		

​		静态方法：

```java
	 static void yield()  让位方法，暂停当前正在执行的线程对象，并执行其他线程。
```

​		yield()方法不是阻塞方法，让当前线程让位，让给其他线程使用。

​		yield()方法的执行会让当前线程从“运行状态”回到“就绪状态”。

​		在回到就绪状态之后，有可能会再次抢到

​		实例方法：

``` 
	 void join() 合并线程
	 class MyThread1 extends Thread{
	 	public void doSame(){
	 		MyThread2 t = new MyThread2();
	 		t.join();  //当前线程进入阻塞，t线程执行，直到t线程结束。当前线程才可以继续。
	 	}
	 }
	 class MyThread2 extends Thread{
	 
	 }
```

2. 关于多线程并发环境下，数据安全的问题

   2.1 为什么这个是重点

   ​		以后在开发中，我们的项目都是运行在服务器当中，而服务器已经将线程的定义，线程对象的创建，线程的启动等，都已经实现完了。这些代码我们都不需要编写

   ​		最重要的是，你要知道，你编写的程序需要放到一个多线程的环境下运行的，你更需要关注的是这些数据在多线程并发的环境下是否是安全的。

   2.2 什么时候数据在多线程并发的环境下会存在安全问题呢？

   ​	三个条件：

   ​		条件1：多线程并发

   ​		条件2：有共享资源

   ​		条件3：共享资源有修改的行为

   ​	满足以上三个条件之后，就会存在线程安全问题

   2.3 怎么解决线程安全问题？

   ​	当线程并发的环境下，有共享资源，并且这个资源还会被修改的。此时就存在线程安全问题，怎么解决这个问题？

   ​		线程排队执行。（不能并发）

   ​		用排队执行解决线程安全问题。

   ​		这种机制被称为：线程同步机制。（会牺牲一部分效率）

    2.4 说到进程同步，涉及两个专业术语：

   ​		异步编程模型：

   ​		线程t1和线程t2，各自执行各自的，t1不管t2，t2不管t1，谁也不需要等谁，		这种编程模		型叫做，异步编程模型。

   ​		其实就是多线程并发（效率较高）。

   

   ​		同步编程模型：

   ​		线程t1和线程t2，在线程t1 执行的时候，必须等待线程t2线程执行结束，或者说在t2线程执		行的时候，必须等待t1线程执行结束，两个线程之间发生了等待关系，这就是同步编程模		型。

   ​		效率较低。线程排队执行

3. Java中有三大变量

   实例变量：在堆中

   静态变量：在方法区中

   局部变量：在栈中

   以上三大变量中：

   ​	局部变量永远都不会存在线程安全问题 。

   ​	因为局部变量不共享（一个线程一个栈。）

   ​	局部变量在栈中，所以局部变量永远都不会共享。

   实例变量在堆中，堆只有一个。

   静态变量在方法区中，方法区只有一个。

   堆和方法区都是多线程共享的，所以可能存在线程安全问题。

   局部变量 + 常量不会有线程安全问题

4. 如果使用局部变量的话：

   建议使用StringBuilder。

   因为局部变量不存在线程安全问题。选择StringBuilder。

   StringBuffer效率比较低。

​		

​		ArrayList是非线程安全的

​		Vector是线程安全的

​		HashMap，HashSet是非线程安全的。

​		Hashtable是线程安全的

5. Synchronized有两种写法：

   第一种：同步代码块

   ​		灵活

   ​		synchronized（线程共享对象）｛

   ​			同步代码块：

​				｝

​		第二种：在实例方法上使用synchronized

​				表示共享对象一定是this

​				并且同步代码块是整个方法体。

​		第三种：在静态方法上使用synchronized

​				表示找类锁。

​				类锁永远只有1把。

6. 我们以后开发中怎么解决线程安全问题？

   ​	synchronized会让程序执行效率降低用户体验不好。系统的用户吞吐量降低。用户体验差。在	不得已的情况下再选择线程同步机制

   ​	第一种方案：尽量使用局部变量代替“实例变量和静态变量”

   ​	

   ​	第二种方案：如果必须是实例变量，那么可以考虑创建多个对象，这样实例变量的内存就不共	享了。（一个线程对应一个对象，对象不共享，就不会发生数据不安全了）



​			第三种方案：如果不能使用局部变量，也不能创建多个对象，这个时候再选择synchronized，			线程同步机制。

7. 线程这块还有哪些内容？

   ​	7.1 守护线程

   ​		Java语言中线程分为两大类：

   ​			一类是：用户线程

   ​			一类是：守护线程（后台线程）

   ​			其中具有代表性的就是：垃圾回收线程（守护线程）。

   ​		守护线程的特点：

   ​			一般守护线程是一个死循环，所有的用户线程只要结束，守护线程自动结束。

   ​		注意：主线程main方法是一个用户线程
   
   ​		守护线程用在什么地方？
   
   ​		
   
   ​	7.2 定时器
   
   ​		定时器的作用：间隔特定的时间，执行特定的程序。
   
   ​		在实际的开发中，每隔多久执行一段特定的程序。
   
   ​		在Java中，可以采用多种方式实现：
   
   ​			可以使用sleep方法，睡眠，每到这个时间醒来，这种方式是最原始的。
   
   ​			在Java中已经写好了一个定时器：java.util.Timer，可以拿来直接用。
   
   ​			在实际开大中，目前使用较多的是Spring框架中的SpringTask框架，这个框架只要进行简单的配置，就可以完成定时器的任务
   
   
   
   ​	7.3 实现线程的第三种方式：FutureTask方式，实现Callable接口
   
   ​		这种方法实现的线程可以获取线程的返回值。
   
   ​		之前的两种方式无法获取线程的返回值。因为run方法的返回值是void
   
   ​	7.4 关于Object中的wait和notify方法（生产者和消费者）
   
   ​		第一：wait和notify方法不是线程对象的方法，是Java中任何一个对象都有的方法，这两个方法是Object中自带的 
   
   ​		第二：wait方法作用		
   
   ```java
   	Object object = new Object();
   	object.wait();
   	表示：
   		让正在对象上活动的线程进入等待状态，无期限等待。直到被唤醒为止。
          	o.wait();方法的调用。会让当前线程(正在o对象上活动的线程)进入等待状态
   ```
   
   ​		第三：notify方法作用
   
   ```
   	Object o = new Object();
   	o.notify();
   	表示：
   		唤醒正在o对象上等待的线程。
   		
   	还有一个notifyAll()方法：
   		这个方法是唤醒o对象上的所有线程。
   		
   ```
   
   synchronized不能直接以Integer对象作为共享对象。
   
   会出现java.lang.IllegaMonnitorStateException异常









